<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>House Pong - 615 Realty Guy</title>
    <style>
        /* General Styles */
        body {
            font-family: 'Futura', sans-serif;
            background-color: #000000;
            color: #d2b56c;
            margin: 0;
            padding: 0;
            text-align: center;
        }

        /* Home Button */
        .home-button {
            margin-top: 10px;
        }

        .home-button a {
            color: #d2b56c;
            text-decoration: none;
            font-size: 1rem;
            padding: 5px 10px;
            border-radius: 5px;
            transition: 0.3s;
        }

        .home-button a:hover {
            color: #feee9f;
        }

        /* Game Styles */
        canvas {
            background: url('https://i.imgur.com/CuZ9Mfx.png') no-repeat center center;
            background-size: cover;
            display: block;
            margin: auto;
            border: 2px solid #d2b56c;
            max-width: 100%;
            height: auto;
        }

        /* Touch Controls */
        .touch-controls {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        .touch-button {
            background: #d2b56c;
            color: #000;
            font-size: 1.2rem;
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation;
        }
        .touch-button:active {
            background: #feee9f;
        }

        /* Start Button Overlay */
        .start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        .start-button {
            background: #d2b56c;
            color: #000;
            font-size: 1.5rem;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }

        .start-button:hover {
            background: #feee9f;
        }

        /* Countdown Overlay */
        .countdown-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            font-size: 3rem;
            color: #d2b56c;
        }

        /* Rebound Counter Styles */
        .rebound-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
            color: #d2b56c;
        }

        /* Pause Button Styles */
        .pause-button {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #d2b56c;
            color: #000;
            font-size: 1.2rem;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }
        .pause-button:hover {
            background: #feee9f;
        }
    </style>
</head>
<body>
    <div class="home-button">
        <a href="https://615realtyguy.com">üè† Home</a>
    </div>
    <h1>House Pong üè°üèì</h1>
    <p>Use the arrow keys (‚¨ÜÔ∏è‚¨áÔ∏è) or touch buttons for mobile users to bounce the contract back & forth</p>
<canvas id="pongCanvas" tabindex="0"></canvas>
    
    <div class="start-overlay" id="startOverlay">
        <button class="start-button" id="startButton">Start Game</button>
    </div>

    <div class="countdown-overlay" id="countdownOverlay" style="display: none;"></div>

    <div class="touch-controls">
        <button class="touch-button" id="upBtn">‚¨ÜÔ∏è</button>
        <button class="touch-button" id="downBtn">‚¨áÔ∏è</button>
    </div>

    <div class="rebound-counter" id="reboundCounter">Rebounds: 0</div>

    <button class="pause-button" id="pauseButton">Pause</button>
    
<script>
  const canvas = document.getElementById("pongCanvas");
  const ctx = canvas.getContext("2d");
  const startButton = document.getElementById("startButton");
  const startOverlay = document.getElementById("startOverlay");
  const countdownOverlay = document.getElementById("countdownOverlay");
  const reboundCounter = document.getElementById("reboundCounter");
  const pauseButton = document.getElementById("pauseButton");

  let gameStarted = false;
  let playerReboundCount = 0;
  let isPaused = false;

  let canvasWidth, canvasHeight;
  let paddleWidth, paddleHeight;
  let leftPaddleY, rightPaddleY;
  let ballX, ballY, ballSpeedX, ballSpeedY;

  // Unified input state
  let moveUp = false;
  let moveDown = false;

  // Collision helpers
  const LEFT_X_CONST = 20;      // visual left emoji x
  let RIGHT_X;                  // computed from canvas width and paddle width
  const EPS = 2;                // push-out distance after a hit
  let canHitRight = true;       // gates to avoid multi-hit
  let canHitLeft  = true;

  // Speed caps
  let maxBallSpeed = 0;

  function resizeCanvas() {
    canvasWidth = Math.max(320, window.innerWidth * 0.9);
    canvasHeight = Math.max(240, window.innerHeight * 0.6);
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    paddleWidth = canvasWidth * 0.03;
    paddleHeight = canvasHeight * 0.2;

    RIGHT_X = canvas.width - 40 - paddleWidth; // matches your draw position
    maxBallSpeed = Math.max(canvasWidth, canvasHeight) * 0.02;

    resetGame();
  }

  function resetBall(serveRight = false) {
    ballX = canvasWidth / 2;
    ballY = canvasHeight / 2;
    const base = canvasWidth * 0.005;
    ballSpeedX = (serveRight ? 1 : -1) * base;
    ballSpeedY = (Math.random() * 2 - 1) * (canvasHeight * 0.005);
    canHitRight = true;
    canHitLeft  = true;
  }

  function resetGame() {
    leftPaddleY = (canvasHeight - paddleHeight) / 2;
    rightPaddleY = (canvasHeight - paddleHeight) / 2;
    resetBall(true);
  }

  function capSpeeds() {
    ballSpeedX = Math.max(-maxBallSpeed, Math.min(maxBallSpeed, ballSpeedX));
    ballSpeedY = Math.max(-maxBallSpeed, Math.min(maxBallSpeed, ballSpeedY));
  }

  function drawRect(x, y, width, height, emoji) {
    ctx.font = `${canvasWidth * 0.05}px Arial`;
    ctx.fillText(emoji, x, y + height / 2);
  }

  function drawBall(x, y, emoji) {
    ctx.font = `${canvasWidth * 0.04}px Arial`;
    ctx.fillText(emoji, x, y);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawRect(LEFT_X_CONST, leftPaddleY, paddleWidth, paddleHeight, "üè°");
    drawRect(RIGHT_X, rightPaddleY, paddleWidth, paddleHeight, "üè°");
    drawBall(ballX, ballY, "üìÑ");
  }

  function handlePaddleInput() {
    const paddleStep = Math.max(1, canvasHeight * 0.0375);
    if (moveUp && rightPaddleY > 0) {
      rightPaddleY = Math.max(0, rightPaddleY - paddleStep);
    }
    if (moveDown && rightPaddleY < canvas.height - paddleHeight) {
      rightPaddleY = Math.min(canvas.height - paddleHeight, rightPaddleY + paddleStep);
    }
  }

  function updateBallAndAI() {
    if (!gameStarted || isPaused) return;

    // Move ball
    ballX += ballSpeedX;
    ballY += ballSpeedY;

    // Top/bottom with position correction
    if (ballY <= 0) {
      ballY = 0;
      ballSpeedY = Math.abs(ballSpeedY);
    } else if (ballY >= canvas.height) {
      ballY = canvas.height;
      ballSpeedY = -Math.abs(ballSpeedY);
    }

    // --------- Paddle collisions (robust) ---------
    const rightHitZoneYMin = rightPaddleY;
    const rightHitZoneYMax = rightPaddleY + paddleHeight;
    const leftHitZoneYMin  = leftPaddleY;
    const leftHitZoneYMax  = leftPaddleY + paddleHeight;

    // Right paddle: only if moving right and gate is open
    if (
      ballSpeedX > 0 &&
      ballX >= RIGHT_X &&
      ballY >= rightHitZoneYMin &&
      ballY <= rightHitZoneYMax &&
      canHitRight
    ) {
      // snap out + reflect
      ballX = RIGHT_X - EPS;
      ballSpeedX = -Math.abs(ballSpeedX);

      // add "spin" based on impact point
      const rel = (ballY - (rightPaddleY + paddleHeight / 2)) / (paddleHeight / 2);
      ballSpeedY += rel * (canvasHeight * 0.004);

      // count once
      playerReboundCount++;
      reboundCounter.textContent = `Rebounds: ${playerReboundCount}`;

      // gentle ramp (cap after)
      if (playerReboundCount % 5 === 0) {
        ballSpeedX *= 1.06;
        ballSpeedY *= 1.06;
      }

      capSpeeds();
      canHitRight = false; // close this side
      canHitLeft  = true;  // open the other side
    }

    // Left paddle: only if moving left and gate is open
    if (
      ballSpeedX < 0 &&
      ballX <= LEFT_X_CONST + paddleWidth &&
      ballY >= leftHitZoneYMin &&
      ballY <= leftHitZoneYMax &&
      canHitLeft
    ) {
      ballX = LEFT_X_CONST + paddleWidth + EPS;
      ballSpeedX = Math.abs(ballSpeedX);

      const rel = (ballY - (leftPaddleY + paddleHeight / 2)) / (paddleHeight / 2);
      ballSpeedY += rel * (canvasHeight * 0.004);

      capSpeeds();
      canHitLeft  = false;
      canHitRight = true;
    }

    // Re-open gates once the ball clearly leaves the paddle zones
    if (ballX < RIGHT_X - paddleWidth) canHitRight = true;
    if (ballX > LEFT_X_CONST + paddleWidth) canHitLeft = true;

    // Out of bounds: reset rally (prevents runaway loops off-screen)
    if (ballX < -50) {
      // player missed left -> serve to right
      resetBall(true);
    } else if (ballX > canvas.width + 50) {
      // player missed right -> serve to left
      resetBall(false);
      // optional: reset player's combo counter
      playerReboundCount = 0;
      reboundCounter.textContent = `Rebounds: ${playerReboundCount}`;
    }

    // --------- Left AI ---------
    const baseSpeed = canvasHeight * 0.005;
    const aiSpeed = baseSpeed + Math.random() * canvasHeight * 0.002;
    const errorMargin = Math.random() * canvasHeight * 0.02 - canvasHeight * 0.01;
    const reactionDelay = Math.random() > 0.7 ? aiSpeed : 0;

    if (leftPaddleY + paddleHeight / 2 < ballY + errorMargin + reactionDelay) {
      leftPaddleY = Math.min(canvasHeight - paddleHeight, leftPaddleY + aiSpeed);
    } else {
      leftPaddleY = Math.max(0, leftPaddleY - aiSpeed);
    }
  }

  function gameLoop() {
    handlePaddleInput();
    updateBallAndAI();
    draw();
    requestAnimationFrame(gameLoop);
  }

  function startCountdown() {
    let countdown = 3;
    countdownOverlay.style.display = "block";
    countdownOverlay.textContent = countdown;

    const countdownInterval = setInterval(() => {
      countdown--;
      if (countdown > 0) {
        countdownOverlay.textContent = countdown;
      } else {
        clearInterval(countdownInterval);
        countdownOverlay.style.display = "none";
        gameStarted = true;
      }
    }, 1000);
  }

  // Start button
  startButton.addEventListener("click", function () {
    startOverlay.style.display = "none";
    startCountdown();
    setTimeout(() => canvas.focus(), 0);
  });

  // Touch + Mouse + Pointer button bindings
  const upBtn = document.getElementById("upBtn");
  const downBtn = document.getElementById("downBtn");

  function bindPress(el, setter) {
    el.addEventListener("pointerdown", (e) => { e.preventDefault(); setter(true); });
    el.addEventListener("pointerup",   (e) => { e.preventDefault(); setter(false); });
    el.addEventListener("pointerleave",         () => setter(false));
    el.addEventListener("touchstart", (e) => { e.preventDefault(); setter(true); }, { passive: false });
    el.addEventListener("touchend",   (e) => { e.preventDefault(); setter(false); }, { passive: false });
    el.addEventListener("mousedown",  (e) => { e.preventDefault(); setter(true); });
    window.addEventListener("mouseup", () => setter(false));
  }

  bindPress(upBtn,   (v) => { moveUp = v; });
  bindPress(downBtn, (v) => { moveDown = v; });

  // Keyboard (Arrow/W/S)
  function isUp(ev) {
    return ev.code === "ArrowUp" || ev.code === "KeyW" || ev.key === "ArrowUp" || ev.key === "w" || ev.key === "W";
  }
  function isDown(ev) {
    return ev.code === "ArrowDown" || ev.code === "KeyS" || ev.key === "ArrowDown" || ev.key === "s" || ev.key === "S";
  }

  window.addEventListener("keydown", (e) => {
    if (isUp(e) || isDown(e)) e.preventDefault();
    if (isUp(e)) moveUp = true;
    if (isDown(e)) moveDown = true;
  }, { passive: false });

  window.addEventListener("keyup", (e) => {
    if (isUp(e) || isDown(e)) e.preventDefault();
    if (isUp(e)) moveUp = false;
    if (isDown(e)) moveDown = false;
  }, { passive: false });

  pauseButton.addEventListener("click", function () {
    isPaused = !isPaused;
    pauseButton.textContent = isPaused ? "Resume" : "Pause";
    canvas.focus();
  });

  window.addEventListener("load", () => { canvas.focus(); });
  canvas.addEventListener("click", () => canvas.focus());
  window.addEventListener("resize", resizeCanvas);

  resizeCanvas();
  gameLoop();
</script>



</body>
</html>
